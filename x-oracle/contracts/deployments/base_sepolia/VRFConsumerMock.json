{
  "address": "0x498b6E28b544fe8fd2FcCa318015a4a924344287",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "coordinator",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "have",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "want",
          "type": "address"
        }
      ],
      "name": "OnlyCoordinatorCanFulfill",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "notOwner",
          "type": "address"
        }
      ],
      "name": "OnlyOwner",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "requestId",
          "type": "uint256"
        }
      ],
      "name": "cancelRequest",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "requestId",
          "type": "uint256"
        },
        {
          "internalType": "uint256[]",
          "name": "randomWords",
          "type": "uint256[]"
        }
      ],
      "name": "rawFulfillRandomWords",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "keyHash",
          "type": "bytes32"
        },
        {
          "internalType": "uint64",
          "name": "accId",
          "type": "uint64"
        },
        {
          "internalType": "uint32",
          "name": "callbackGasLimit",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "numWords",
          "type": "uint32"
        }
      ],
      "name": "requestRandomWords",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "requestId",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "keyHash",
          "type": "bytes32"
        },
        {
          "internalType": "uint32",
          "name": "callbackGasLimit",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "numWords",
          "type": "uint32"
        },
        {
          "internalType": "address",
          "name": "refundRecipient",
          "type": "address"
        }
      ],
      "name": "requestRandomWordsDirectPayment",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "requestId",
          "type": "uint256"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "sRandomWord",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "accId",
          "type": "uint64"
        }
      ],
      "name": "withdrawTemporary",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "transactionHash": "0x74d10a4ab0dd684b5ef104b99b676921ebab6a2878d57828a88e0c704d8b8bb4",
  "receipt": {
    "to": null,
    "from": "0x8b736035BbDA71825e0219f5FE4DfB22C35FbDDC",
    "contractAddress": "0x498b6E28b544fe8fd2FcCa318015a4a924344287",
    "transactionIndex": 17,
    "gasUsed": "566540",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x12a7975eae3a280acd1e7df25ede6f2ba29c945087a194242fb2f69797318624",
    "transactionHash": "0x74d10a4ab0dd684b5ef104b99b676921ebab6a2878d57828a88e0c704d8b8bb4",
    "logs": [],
    "blockNumber": 27266092,
    "cumulativeGasUsed": "6884239",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x9A2699517c3F9955B64F848e683aaDF4AB7BD54B"
  ],
  "numDeployments": 1,
  "solcInputHash": "828fa1b778bad7ac1d584cb61e4cf690",
  "metadata": "{\"compiler\":{\"version\":\"0.8.16+commit.07a7930e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"coordinator\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"have\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"want\",\"type\":\"address\"}],\"name\":\"OnlyCoordinatorCanFulfill\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"notOwner\",\"type\":\"address\"}],\"name\":\"OnlyOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"cancelRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"randomWords\",\"type\":\"uint256[]\"}],\"name\":\"rawFulfillRandomWords\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"keyHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"accId\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"callbackGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"numWords\",\"type\":\"uint32\"}],\"name\":\"requestRandomWords\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"keyHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"callbackGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"numWords\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"refundRecipient\",\"type\":\"address\"}],\"name\":\"requestRandomWordsDirectPayment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sRandomWord\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"accId\",\"type\":\"uint64\"}],\"name\":\"withdrawTemporary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"rawFulfillRandomWords(uint256,uint256[])\":{\"params\":{\"randomWords\":\"the VRF output expanded to the requested number of words\",\"requestId\":\"The Id initially returned by requestRandomWords\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"rawFulfillRandomWords(uint256,uint256[])\":{\"notice\":\"rawFulfillRandomWords is called by VRFCoordinator when itreceives a valid VRF proof. rawFulfillRandomWords then callsfulfillRandomWords, after validating the origin of the call\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/mocks/VRFConsumerMock.sol\":\"VRFConsumerMock\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[]},\"sources\":{\"src/VRFConsumerBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\n// https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/VRFConsumerBaseV2.sol\\n\\n/** ****************************************************************************\\n * @notice Interface for contracts using VRF randomness\\n * *****************************************************************************\\n * @dev PURPOSE\\n *\\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\\n * @dev making his output up to suit himself. Reggie provides Vera a public key\\n * @dev to which he knows the secret key. Each time Vera provides a seed to\\n * @dev Reggie, he gives back a value which is computed completely\\n * @dev deterministically from the seed and the secret key.\\n *\\n * @dev Reggie provides a proof by which Vera can verify that the output was\\n * @dev correctly computed once Reggie tells it to her, but without that proof,\\n * @dev the output is indistinguishable to her from a uniform random sample\\n * @dev from the output space.\\n *\\n * @dev The purpose of this contract is to make it easy for unrelated contracts\\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\\n * @dev 1. The fulfillment came from the VRFCoordinator\\n * @dev 2. The consumer contract implements fulfillRandomWords.\\n * *****************************************************************************\\n * @dev USAGE\\n *\\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\\n * @dev initialize VRFConsumerBase's attributes in their constructor as\\n * @dev shown:\\n *\\n * @dev   contract VRFConsumer {\\n * @dev     constructor(<other arguments>, address _vrfCoordinator)\\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\\n * @dev         <initialization with other arguments goes here>\\n * @dev       }\\n * @dev   }\\n *\\n * @dev The oracle will have given you an ID for the VRF keypair they have\\n * @dev committed to (let's call it keyHash). Create account, fund it\\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\\n * @dev account management functions).\\n * @dev Call requestRandomWords(keyHash, accId,\\n * @dev callbackGasLimit, numWords),\\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\\n *\\n * @dev Once the VRFCoordinator has received and validated the oracle's response\\n * @dev to your request, it will call your contract's fulfillRandomWords method.\\n *\\n * @dev The randomness argument to fulfillRandomWords is a set of random words\\n * @dev generated from your requestId and the blockHash of the request.\\n *\\n * @dev If your contract could have concurrent requests open, you can use the\\n * @dev requestId returned from requestRandomWords to track which response is associated\\n * @dev with which randomness request.\\n * @dev See \\\"SECURITY CONSIDERATIONS\\\" for principles to keep in mind,\\n * @dev if your contract could have multiple requests in flight simultaneously.\\n *\\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\\n * @dev differ.\\n *\\n * *****************************************************************************\\n * @dev SECURITY CONSIDERATIONS\\n *\\n * @dev A method with the ability to call your fulfillRandomWords method directly\\n * @dev could spoof a VRF response with any random value, so it's critical that\\n * @dev it cannot be directly called by anything other than this base contract\\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomWords method).\\n *\\n * @dev For your users to trust that your contract's random behavior is free\\n * @dev from malicious interference, it's best if you can write it so that all\\n * @dev behaviors implied by a VRF response are executed *during* your\\n * @dev fulfillRandomWords method. If your contract must store the response (or\\n * @dev anything derived from it) and use it later, you must ensure that any\\n * @dev user-significant behavior which depends on that stored value cannot be\\n * @dev manipulated by a subsequent VRF request.\\n *\\n * @dev Similarly, both miners and the VRF oracle itself have some influence\\n * @dev over the order in which VRF responses appear on the blockchain, so if\\n * @dev your contract could have multiple VRF requests in flight simultaneously,\\n * @dev you must ensure that the order in which the VRF responses arrive cannot\\n * @dev be used to manipulate your contract's user-significant behavior.\\n *\\n * @dev Since the block hash of the block which contains the requestRandomWords\\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\\n * @dev miner could, in principle, fork the blockchain to evict the block\\n * @dev containing the request, forcing the request to be included in a\\n * @dev different block with a different hash, and therefore a different input\\n * @dev to the VRF. However, such an attack would incur a substantial economic\\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\\n * @dev until it calls responds to a request. It is for this reason that\\n * @dev you can signal to an oracle you'd like them to wait longer before\\n * @dev responding to the request (however this is not enforced in the contract\\n * @dev and so remains effective only in the case of unmodified oracle software).\\n */\\nabstract contract VRFConsumerBase {\\n    error OnlyCoordinatorCanFulfill(address have, address want);\\n    address private immutable vrfCoordinator;\\n\\n    /**\\n     * @param _vrfCoordinator address of VRFCoordinator contract\\n     */\\n    constructor(address _vrfCoordinator) {\\n        vrfCoordinator = _vrfCoordinator;\\n    }\\n\\n    /**\\n     * @notice fulfillRandomWords handles the VRF response. Your contract must\\n     * @notice implement it. See \\\"SECURITY CONSIDERATIONS\\\" above for important\\n     * @notice principles to keep in mind when implementing your fulfillRandomWords\\n     * @notice method.\\n     *\\n     * @dev VRFConsumerBase expects its subcontracts to have a method with this\\n     * @dev signature, and will call it once it has verified the proof\\n     * @dev associated with the randomness. (It is triggered via a call to\\n     * @dev rawFulfillRandomWords, below.)\\n     *\\n     * @param requestId The Id initially returned by requestRandomWords\\n     * @param randomWords the VRF output expanded to the requested number of words\\n     */\\n    function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\\n\\n    /**\\n     * @notice rawFulfillRandomWords is called by VRFCoordinator when it\\n     * @notice receives a valid VRF proof. rawFulfillRandomWords then calls\\n     * @notice fulfillRandomWords, after validating the origin of the call\\n     *\\n     * @param requestId The Id initially returned by requestRandomWords\\n     * @param randomWords the VRF output expanded to the requested number of words\\n     */\\n    function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\\n        if (msg.sender != vrfCoordinator) {\\n            revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\\n        }\\n        fulfillRandomWords(requestId, randomWords);\\n    }\\n}\\n\",\"keccak256\":\"0x8f25cf557237f53059663038b409a6a09210710ebc86bed6f416d418c02f6425\",\"license\":\"MIT\"},\"src/interfaces/IAccount.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\ninterface IAccount {\\n    /// READ-ONLY FUNCTIONS /////////////////////////////////////////////////////\\n    enum AccountType {\\n        TEMPORARY,\\n        FIAT_SUBSCRIPTION,\\n        KLAY_SUBSCRIPTION,\\n        KLAY_DISCOUNT,\\n        KLAY_REGULAR\\n    }\\n\\n    /**\\n     * @notice Get an account information.\\n     * @return balance - KLAY balance of the account in juels.\\n     * @return reqCount - number of requests for this account, determines fee tier.\\n     * @return owner - owner of the account.\\n     * @return consumers - list of consumer address which are able to use this account.\\n     * @return accType\\n     */\\n    function getAccount()\\n        external\\n        view\\n        returns (\\n            uint256 balance,\\n            uint64 reqCount,\\n            address owner,\\n            address[] memory consumers,\\n            AccountType accType\\n        );\\n\\n    /**\\n     * @notice Return an account ID that is associated with this account.\\n     * @return account ID\\n     */\\n    function getAccountId() external returns (uint64);\\n\\n    /**\\n     * @notice Return an amount of KLAY held in the Account contract.\\n     * @return balance of account\\n     */\\n    function getBalance() external returns (uint256);\\n\\n    /**\\n     * @notice Return the number of requests created through the\\n     * @notice account.\\n     * @return number of requests\\n     */\\n    function getReqCount() external returns (uint64);\\n\\n    /**\\n     * @notice Return the current owner of account.\\n     * @return owner address\\n     */\\n    function getOwner() external returns (address);\\n\\n    /**\\n     * @notice Return the consumers assigned to the account.\\n     * @return list of consumer addresses\\n     */\\n    function getConsumers() external returns (address[] memory);\\n\\n    /**\\n     * @notice Return the requested owner of account.\\n     * @return requested owner address\\n     */\\n    function getRequestedOwner() external returns (address);\\n\\n    /**\\n     * @notice Return the current nonce of given consumer.\\n     * @return consumer nonce\\n     */\\n    function getNonce(address consumer) external view returns (uint64);\\n\\n    /**\\n     * @notice Return the address of payment solution associated with account.\\n     * @return address of payment solution\\n     */\\n    function getPaymentSolution() external view returns (address);\\n\\n    /// STATE-ALTERING FUNCTIONS ////////////////////////////////////////////////\\n\\n    /**\\n     * @notice Increase nonce for given consumer.\\n     * @param consumer - Address of consumer\\n     */\\n    function increaseNonce(address consumer) external returns (uint64);\\n\\n    /**\\n     * @notice Request account owner transfer.\\n     * @param newOwner - proposed new owner of the account\\n     */\\n    function requestAccountOwnerTransfer(address newOwner) external;\\n\\n    /**\\n     * @notice Request account owner transfer.\\n     * @dev will revert if original owner of accId has\\n     * not requested that msg.sender become the new owner.\\n     * @param newOwner - proposed new owner of the account\\n     */\\n    function acceptAccountOwnerTransfer(address newOwner) external;\\n\\n    /**\\n     * @notice Add a consumer to an account.\\n     * @param consumer - New consumer which can use the account\\n     */\\n    function addConsumer(address consumer) external;\\n\\n    /**\\n     * @notice Remove a consumer from a account.\\n     * @param consumer - Consumer to remove from the account\\n     */\\n    function removeConsumer(address consumer) external;\\n\\n    /**\\n     * @notice Withdraw KLAY from account.\\n     * @dev Only account owner can withdraw KLAY.\\n     * @param amount - KLAY amount to be withdrawn\\n     */\\n    function withdraw(uint256 amount) external returns (bool, uint256);\\n\\n    /**\\n     * @notice Burn part of fee and charge protocol fee for a service\\n     * connected to account.\\n     * @param burnFee - $KLAY amount to be burnt\\n     * @param protocolFee - $KLAY amount to be sent to protocol fee recipient\\n     * @param protocolFeeRecipient - address of Orakl Network\\n     */\\n    function chargeFee(uint256 burnFee, uint256 protocolFee, address protocolFeeRecipient) external;\\n\\n    /**\\n     * @notice Charge operator fee for a service connected to account.\\n     * @param operatorFee - $KLAY amount to be send to oracle operator\\n     * fee recipient\\n     * @param operatorFeeRecipient - address of Orakl Network\\n     */\\n    function chargeOperatorFee(uint256 operatorFee, address operatorFeeRecipient) external;\\n\\n    /**\\n     * @notice Destroy the smart contract and send the remaining $KLAY\\n     * @notice to `to` address.\\n     * @param to - Where to send the remaining KLAY to\\n     */\\n    function cancelAccount(address to) external;\\n\\n    function getAccountDetail() external view returns (uint256, uint256, uint256, uint256);\\n\\n    function getSubscriptionPaid() external view returns (bool);\\n\\n    function updateAccountDetail(\\n        uint256 startDate,\\n        uint256 period,\\n        uint256 reqPeriodCount,\\n        uint256 subscriptionPrice\\n    ) external;\\n\\n    function setSubscriptionPaid() external;\\n\\n    function isValidReq() external view returns (bool);\\n\\n    function getFeeRatio() external view returns (uint256);\\n\\n    function setFeeRatio(uint256 disCount) external;\\n\\n    function increaseSubReqCount() external;\\n}\\n\",\"keccak256\":\"0xbe360ed3c03e7a26ae6b20f9b4c2d7428d516873eab21e780ed8d315a658063d\",\"license\":\"MIT\"},\"src/interfaces/ICoordinatorBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\ninterface ICoordinatorBase {\\n    // Fee configuration that separates fees based on the number of\\n    // requests created per account. This applies only to [regular]\\n    // account.\\n    struct FeeConfig {\\n        // Flat fee charged per fulfillment in millionths of KLAY\\n        // So fee range is [0, 2^32/10^6].\\n        uint32 fulfillmentFlatFeeKlayPPMTier1;\\n        uint32 fulfillmentFlatFeeKlayPPMTier2;\\n        uint32 fulfillmentFlatFeeKlayPPMTier3;\\n        uint32 fulfillmentFlatFeeKlayPPMTier4;\\n        uint32 fulfillmentFlatFeeKlayPPMTier5;\\n        uint24 reqsForTier2;\\n        uint24 reqsForTier3;\\n        uint24 reqsForTier4;\\n        uint24 reqsForTier5;\\n    }\\n\\n    /**\\n     * @notice Sets the configuration of the VRF coordinator\\n     * @param maxGasLimit global max for request gas limit\\n     * @param gasAfterPaymentCalculation gas used in doing accounting\\n     * after completing the gas measurement\\n     * @param feeConfig fee tier configuration\\n     */\\n    function setConfig(\\n        uint32 maxGasLimit,\\n        uint32 gasAfterPaymentCalculation,\\n        FeeConfig memory feeConfig\\n    ) external;\\n\\n    /**\\n     * @notice Check to see if there exists a request commitment\\n     * consumers for all consumers and keyhashes for a given acc.\\n     * @param accId - ID of the account\\n     * @return true if there exists at least one unfulfilled request\\n     * for the account, false otherwise.\\n     */\\n    function pendingRequestExists(\\n        address consumer,\\n        uint64 accId,\\n        uint64 nonce\\n    ) external view returns (bool);\\n\\n    /**\\n     * @notice Get request commitment.\\n     * @param requestId id of request\\n     * @return commmitment value that can be used to determine whether\\n     * a request is fulfilled or not. If `requestId` is valid and\\n     * commitment equals to bytes32(0), the request was fulfilled.\\n     */\\n    function getCommitment(uint256 requestId) external view returns (bytes32);\\n\\n    /**\\n     * @notice Canceling oracle request\\n     * @param requestId - ID of the Oracle Request\\n     */\\n    function cancelRequest(uint256 requestId) external;\\n\\n    /**\\n     * @notice Access address for prepayment associated with\\n     * @notice coordinator.\\n     * @return prepayment address\\n     */\\n    function getPrepaymentAddress() external returns (address);\\n\\n    function estimateFee(\\n        uint64 reqCount,\\n        uint8 numSubmission,\\n        uint32 callbackGasLimit\\n    ) external returns (uint256);\\n}\\n\",\"keccak256\":\"0x6de51eefb1bee236f7a8144f87c06b804f11375672f41543926a960b9d50f8b5\",\"license\":\"MIT\"},\"src/interfaces/IPrepayment.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\nimport \\\"./IAccount.sol\\\";\\n\\ninterface IPrepayment {\\n    /// READ-ONLY FUNCTIONS /////////////////////////////////////////////////////\\n\\n    /**\\n     * @notice Returns `true` when a `consumer` is registered under\\n     * @notice `accId`, otherwise returns `false`.\\n     * @dev This function can be used for checking validity of both\\n     * @dev [regular] and [temporary] account.\\n     * @param accId - ID of the account\\n     */\\n    function isValidAccount(uint64 accId, address consumer) external view returns (bool);\\n\\n    /**\\n     * @notice Returns the balance of given account.\\n     * @dev This function is meant to be used only for [regular]\\n     * @dev account. If invalid `accId` (ID not assigned to any\\n     * @dev account) is passed, zero balance will be always returned.\\n     * @param accId - ID of the account\\n     * @return balance of account\\n     */\\n    function getBalance(uint64 accId) external view returns (uint256);\\n\\n    /**\\n     * @notice Return the number of requests created through the\\n     * @notice account.\\n     * @dev This function is meant to be used only for [regular]\\n     * @dev account.\\n     * @param accId - ID of the account\\n     * @return number of requests\\n     */\\n    function getReqCount(uint64 accId) external view returns (uint64);\\n\\n    /**\\n     * @notice Get an account information.\\n     * @dev This function can be used for both [regular] and\\n     * @dev [temporary] account.\\n     * @param accId - ID of the account\\n     * @return balance - $KLAY balance of the account in juels.\\n     * @return reqCount - number of requests for this account, determines fee tier.\\n     * @return owner - owner of the account.\\n     * @return consumers - list of consumer address which are able to use this account.\\n     */\\n    function getAccount(\\n        uint64 accId\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 balance,\\n            uint64 reqCount,\\n            address owner,\\n            address[] memory consumers,\\n            IAccount.AccountType accType\\n        );\\n\\n    /**\\n     * @notice Get address of account owner.\\n     * @dev This function is meant to be used only for [regular]\\n     * @dev account.\\n     * @param accId - ID of the account\\n     */\\n    function getAccountOwner(uint64 accId) external returns (address);\\n\\n    /**\\n     * @notice Get nonce for specified `consumer` in account denoted by `accId`.\\n     * @dev This function is meant to be used only for [regular]\\n     * @dev account. [temporary] account does not have a notion of a nonce.\\n     * @dev When an invalid `accId` is passed, transaction is\\n     * @dev reverted. When an invalid `consumer` is passed, 0 zero\\n     * @dev nonce is returned that represents an unregistered consumer.\\n     * @param accId - ID of the account\\n     * @param consumer - consumer address\\n     */\\n    function getNonce(uint64 accId, address consumer) external view returns (uint64);\\n\\n    /*\\n     * @notice Check to see if there exists a request commitment\\n     * @notice for all consumers and coordinators for a given\\n     * @notice [permanent] account.\\n     * @dev Use to reject account cancelation while outstanding\\n     * @dev request are present.\\n     * @param accId - ID of the account\\n     * @return true if there exists at least one unfulfilled request for the account, false\\n     * otherwise.\\n     */\\n    function pendingRequestExists(uint64 accId) external view returns (bool);\\n\\n    /*\\n     * @notice Check to see if there exists a request commitment\\n     * @notice for an account owner of [temporary] account across\\n     * @notice all coordinators.\\n     * @dev Use to reject balance withdrawal while outstanding\\n     * @dev request are present.\\n     * @param accId - ID of the account\\n     * @return true if there exists at least one unfulfilled request for the account, false\\n     * otherwise.\\n     */\\n    function pendingRequestExistsTemporary(uint64 accId) external view returns (bool);\\n\\n    /// STATE-ALTERING FUNCTIONS ////////////////////////////////////////////////\\n\\n    /**\\n     * @notice Create a [regular] account.\\n     * @dev This function deploys a new `Account` contract (defined at\\n     * @dev Account.sol) and connect it with the `Prepayment` contract.\\n     * @dev You can add or remove the consumer dynamically with\\n     * @dev `addConsumer` or `removeConsumer` functions,\\n     * @dev respectively. To fund the account, use deposit function.\\n     * @return accId - A unique account id\\n     */\\n    function createAccount() external returns (uint64);\\n\\n    function createFiatSubscriptionAccount(\\n        uint256 startDate,\\n        uint256 period,\\n        uint256 reqPeriodCount,\\n        address accOwner\\n    ) external returns (uint64);\\n\\n    function createKlaySubscriptionAccount(\\n        uint256 startDate,\\n        uint256 period,\\n        uint256 reqPeriodCount,\\n        uint256 subscriptionPrice,\\n        address accOwner\\n    ) external returns (uint64);\\n\\n    function createKlayDiscountAccount(\\n        uint256 feeRatio,\\n        address accOwner\\n    ) external returns (uint64);\\n\\n    /**\\n     * @notice Create a temporary account to be used with a single\\n     * @notice service request.\\n     * @param - account owner\\n     * @return accId - A unique account id\\n     */\\n    function createTemporaryAccount(address owner) external returns (uint64);\\n\\n    /**\\n     * @notice Request account owner transfer.\\n     * @dev Only [regular] account owner can be transferred.\\n     * @param accId - ID of the account\\n     * @param newOwner - proposed new owner of the account\\n     */\\n    function requestAccountOwnerTransfer(uint64 accId, address newOwner) external;\\n\\n    /**\\n     * @notice Accept account owner transfer.\\n     * @dev The function will revert inside of the\\n     * @dev `Account.acceptAccountOwnerTransfer` if original owner of\\n     * @dev `accId` has not requested the `msg.sender` to become the\\n     * @dev new owner.\\n     * @param accId - ID of the account\\n     */\\n    function acceptAccountOwnerTransfer(uint64 accId) external;\\n\\n    /**\\n     * @notice Cancel account\\n     * @dev This function is meant to be used only for [regular]\\n     * @dev account. If there is any pending request, the account\\n     * @dev cannot be canceled.\\n     * @param accId - ID of the account\\n     * @param to - Where to send the remaining $KLAY to\\n     */\\n    function cancelAccount(uint64 accId, address to) external;\\n\\n    /**\\n     * @notice Add a consumer to an account.\\n     * @dev This function is meant to be used only for [regular]\\n     * @dev account. If called with [temporary] account, the\\n     * @dev transaction will be reverted.\\n     * @param accId - ID of the account\\n     * @param consumer - New consumer which can use the account\\n     */\\n    function addConsumer(uint64 accId, address consumer) external;\\n\\n    /**\\n     * @notice Remove a consumer from a account.\\n     * @dev This function is meant to be used only for [regular]\\n     * @dev account. If called with [temporary] account, the\\n     * @dev transaction will be reverted.\\n     * @param accId - ID of the account\\n     * @param consumer - Consumer to remove from the account\\n     */\\n    function removeConsumer(uint64 accId, address consumer) external;\\n\\n    /**\\n     * @notice Deposit $KLAY to [regular] account.\\n     * @notice Anybody can deposit $KLAY, there are no restrictions.\\n     * @param accId - ID of the account\\n     */\\n    function deposit(uint64 accId) external payable;\\n\\n    /**\\n     * @notice Deposit $KLAY to [temporary] account.\\n     * @notice Anybody can deposit $KLAY, there are no restrictions.\\n     * @param accId - ID of the account\\n     */\\n    function depositTemporary(uint64 accId) external payable;\\n\\n    /**\\n     * @notice Withdraw $KLAY from [regular] account.\\n     * @dev Account owner can withdraw $KLAY only when there are no\\n     * @dev pending requests on any of associated consumers. If one tries\\n     * @dev to use it to withdraw $KLAY from [temporary] account,\\n     * @dev transaction will revert. Transaction reverts also on failure to\\n     * @dev withdraw tokens from account.\\n     * @param accId - ID of the account\\n     * @param amount - $KLAY amount to be withdrawn\\n     */\\n    function withdraw(uint64 accId, uint256 amount) external;\\n\\n    /**\\n     * @notice Withdraw $KLAY from [temporary] account.\\n     * @dev Account owner can withdraw $KLAY only when there are no\\n     * @dev pending requests. Temporary account will be deleted upon\\n     * @dev successful withdrawal. Transaction reverts also on failure to\\n     * @dev withdraw tokens from account.\\n     * @param accId - ID of the account\\n     * @param to - recipient address\\n     */\\n    function withdrawTemporary(uint64 accId, address payable to) external;\\n\\n    /**\\n     * @notice Burn part of fee and charge protocol fee for a service\\n     * connected to [regular] account.\\n     * @param accId - ID of the account\\n     * @param amount - $KLAY amount to be charged\\n     */\\n    function chargeFee(uint64 accId, uint256 amount) external returns (uint256);\\n\\n    /**\\n     * @notice Charge operator fee for a service connected to\\n     * [temporary] account.\\n     * @param accId - ID of the account\\n     * @param operatorFee - amount of fee to be paid to operator fee\\n     * recipient\\n     * @param operatorFeeRecipient - address of operator fee recipient\\n     */\\n    function chargeOperatorFee(\\n        uint64 accId,\\n        uint256 operatorFee,\\n        address operatorFeeRecipient\\n    ) external;\\n\\n    /**\\n     * @notice Burn part of fee and charge protocol fee for a service\\n     * connected to [temporary] account.\\n     * @dev Temporary account is deleted because we do not expect to use it again.\\n     * @param accId - ID of the account\\n     */\\n    function chargeFeeTemporary(\\n        uint64 accId\\n    ) external returns (uint256 totalAmount, uint256 operatorAmount);\\n\\n    /**\\n     * @notice Charge operator fee for a service connected to\\n     * [temporary] account.\\n     * @param operatorFee - amount of fee to be paid to operator fee\\n     * recipient\\n     * @param operatorFeeRecipient - address of operator fee recipient\\n     */\\n    function chargeOperatorFeeTemporary(uint256 operatorFee, address operatorFeeRecipient) external;\\n\\n    /**\\n     * @notice Increase nonce for consumer registered under accId.\\n     * @param accId - ID of the account\\n     * @param consumer - Address of consumer registered under accId\\n     */\\n    function increaseNonce(uint64 accId, address consumer) external returns (uint64);\\n\\n    /*\\n     * @notice Add coordinator that will be able to charge account for\\n     * @notice the requested service.\\n     * @param coordinator - address of coordinator\\n     */\\n    function addCoordinator(address coordinator) external;\\n\\n    /*\\n     * @notice Disable the coordinator from being able to charge\\n     * @notice accounts for its service.\\n     * @param coordinator - address of coordinator\\n     */\\n    function removeCoordinator(address coordinator) external;\\n\\n    function getBurnFeeRatio() external view returns (uint8);\\n\\n    function getProtocolFeeRatio() external view returns (uint8);\\n\\n    function getAccountDetail(\\n        uint64 accId\\n    ) external view returns (uint256, uint256, uint256, uint256);\\n\\n    function getSubscriptionPaid(uint64 accId) external view returns (bool);\\n\\n    function isValidReq(uint64 accId) external view returns (bool);\\n\\n    function getFeeRatio(uint64 accId) external view returns (uint256);\\n\\n    function updateAccountDetail(\\n        uint64 accId,\\n        uint256 startTime,\\n        uint256 endTime,\\n        uint256 periodReqCount,\\n        uint256 subscriptionPrice\\n    ) external;\\n\\n    function setSubscriptionPaid(uint64 accId) external;\\n\\n    function setFeeRatio(uint64 accId, uint256 disCount) external;\\n\\n    function increaseSubReqCount(uint64 accId) external;\\n}\\n\",\"keccak256\":\"0x05b55249da08c9342213666a3fc935bcbcc54e19c5e6c2946a466ae7038de01c\",\"license\":\"MIT\"},\"src/interfaces/IVRFCoordinator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport \\\"./IVRFCoordinatorBase.sol\\\";\\nimport \\\"./ICoordinatorBase.sol\\\";\\n\\ninterface IVRFCoordinator is IVRFCoordinatorBase, ICoordinatorBase {}\\n\",\"keccak256\":\"0x6b0474d5d4482ff306990782da936d88f2ed1d251f9105c2f3f988699a4d42f5\",\"license\":\"MIT\"},\"src/interfaces/IVRFCoordinatorBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\ninterface IVRFCoordinatorBase {\\n    // RequestCommitment holds information sent from off-chain oracle\\n    // describing details of request.\\n    struct RequestCommitment {\\n        uint256 blockNum;\\n        uint64 accId;\\n        uint32 callbackGasLimit;\\n        uint32 numWords;\\n        address sender;\\n    }\\n\\n    /**\\n     * @notice Get configuration relevant for making requests\\n     * @return maxGasLimit global max for request gas limit\\n     * @return sKeyHashes list of registered key hashes\\n     */\\n    function getRequestConfig() external view returns (uint32, bytes32[] memory);\\n\\n    /**\\n     * @notice Request a set of random words using a [regular] account.\\n     * @param keyHash - Corresponds to a particular oracle job which uses\\n     * that key for generating the VRF proof. Different keyHash's have different gas price\\n     * ceilings, so you can select a specific one to bound your maximum per request cost.\\n     * @param accId - The ID of the account. Must be funded\\n     * with the minimum account balance required for the selected keyHash.\\n     * @param callbackGasLimit - How much gas you'd like to receive in your\\n     * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\\n     * may be slightly less than this amount because of gas used calling the function\\n     * (argument decoding etc.), so you may need to request slightly more than you expect\\n     * to have inside fulfillRandomWords. The acceptable range is\\n     * [0, maxGasLimit]\\n     * @param numWords - The number of uint256 random values you'd like to receive\\n     * in your fulfillRandomWords callback. Note these numbers are expanded in a\\n     * secure way by the VRFCoordinator from a single random value supplied by the oracle.\\n     * @return requestId - A unique identifier of the request. Can be used to match\\n     * a request to a response in fulfillRandomWords.\\n     */\\n    function requestRandomWords(\\n        bytes32 keyHash,\\n        uint64 accId,\\n        uint32 callbackGasLimit,\\n        uint32 numWords\\n    ) external returns (uint256 requestId);\\n\\n    /**\\n     * @notice Request a set of random words using a [temporary] account.\\n     * @param keyHash - Corresponds to a particular oracle job which uses\\n     * that key for generating the VRF proof. Different keyHash's have different gas price\\n     * ceilings, so you can select a specific one to bound your maximum per request cost.\\n     * @param callbackGasLimit - How much gas you'd like to receive in your\\n     * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\\n     * may be slightly less than this amount because of gas used calling the function\\n     * (argument decoding etc.), so you may need to request slightly more than you expect\\n     * to have inside fulfillRandomWords. The acceptable range is\\n     * [0, maxGasLimit]\\n     * @param numWords - The number of uint256 random values you'd like to receive\\n     * in your fulfillRandomWords callback. Note these numbers are expanded in a\\n     * secure way by the VRFCoordinator from a single random value supplied by the oracle.\\n     * @param refundRecipient recipient of an extra $KLAY amount that\\n     * was sent together with service request\\n     * @return requestId - A unique identifier of the request. Can be used to match\\n     * a request to a response in fulfillRandomWords.\\n     */\\n    function requestRandomWords(\\n        bytes32 keyHash,\\n        uint32 callbackGasLimit,\\n        uint32 numWords,\\n        address refundRecipient\\n    ) external payable returns (uint256 requestId);\\n}\\n\",\"keccak256\":\"0x0d8bd0618a35c5cb1424df6f2abbb19c820560a829f5c80997cd7b9e086cbbc1\",\"license\":\"MIT\"},\"src/mocks/VRFConsumerMock.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport \\\"../VRFConsumerBase.sol\\\";\\nimport \\\"../interfaces/IVRFCoordinator.sol\\\";\\nimport \\\"../interfaces/IPrepayment.sol\\\";\\n\\ncontract VRFConsumerMock is VRFConsumerBase {\\n    uint256 public sRandomWord;\\n    address private sOwner;\\n\\n    IVRFCoordinator COORDINATOR;\\n\\n    error OnlyOwner(address notOwner);\\n\\n    modifier onlyOwner() {\\n        if (msg.sender != sOwner) {\\n            revert OnlyOwner(msg.sender);\\n        }\\n        _;\\n    }\\n\\n    constructor(address coordinator) VRFConsumerBase(coordinator) {\\n        sOwner = msg.sender;\\n        COORDINATOR = IVRFCoordinator(coordinator);\\n    }\\n\\n    // Receive remaining payment from requestRandomWordsPayment\\n    receive() external payable {}\\n\\n    function requestRandomWords(\\n        bytes32 keyHash,\\n        uint64 accId,\\n        uint32 callbackGasLimit,\\n        uint32 numWords\\n    ) public onlyOwner returns (uint256 requestId) {\\n        requestId = COORDINATOR.requestRandomWords(keyHash, accId, callbackGasLimit, numWords);\\n    }\\n\\n    function requestRandomWordsDirectPayment(\\n        bytes32 keyHash,\\n        uint32 callbackGasLimit,\\n        uint32 numWords,\\n        address refundRecipient\\n    ) public payable onlyOwner returns (uint256 requestId) {\\n        requestId = COORDINATOR.requestRandomWords{value: msg.value}(\\n            keyHash,\\n            callbackGasLimit,\\n            numWords,\\n            refundRecipient\\n        );\\n    }\\n\\n    function fulfillRandomWords(\\n        uint256 /* requestId */,\\n        uint256[] memory randomWords\\n    ) internal override {\\n        // requestId should be checked if it matches the expected request\\n        // Generate random value between 1 and 50.\\n        sRandomWord = (randomWords[0] % 50) + 1;\\n    }\\n\\n    function cancelRequest(uint256 requestId) external onlyOwner {\\n        COORDINATOR.cancelRequest(requestId);\\n    }\\n\\n    function withdrawTemporary(uint64 accId) external onlyOwner {\\n        address prepaymentAddress = COORDINATOR.getPrepaymentAddress();\\n        IPrepayment(prepaymentAddress).withdrawTemporary(accId, payable(msg.sender));\\n    }\\n}\\n\",\"keccak256\":\"0x97c34eddab9686938b3748204cab2eefa2b3173b62153554c6cb8e6cf1c4a05e\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a060405234801561001057600080fd5b5060405161093138038061093183398101604081905261002f91610063565b6001600160a01b03166080819052600180546001600160a01b03199081163317909155600280549091169091179055610093565b60006020828403121561007557600080fd5b81516001600160a01b038116811461008c57600080fd5b9392505050565b60805161087c6100b56000396000818161028001526102db015261087c6000f3fe6080604052600436106100695760003560e01c80632f34077b116100435780632f34077b146100df5780633015394c146100ff578063ff27dd5e1461011f57600080fd5b80630e5ff996146100755780631964176c1461009d5780631fe543e3146100bf57600080fd5b3661007057005b600080fd5b34801561008157600080fd5b5061008b60005481565b60405190815260200160405180910390f35b3480156100a957600080fd5b506100bd6100b83660046105ce565b610132565b005b3480156100cb57600080fd5b506100bd6100da366004610606565b610275565b3480156100eb57600080fd5b5061008b6100fa3660046106e4565b610316565b34801561010b57600080fd5b506100bd61011a366004610731565b6103fb565b61008b61012d366004610762565b6104a2565b6001546001600160a01b0316331461016457604051630543601560e11b81523360048201526024015b60405180910390fd5b600254604080517fa690d7ae00000000000000000000000000000000000000000000000000000000815290516000926001600160a01b03169163a690d7ae916004808301926020929190829003018187875af11580156101c8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101ec91906107b1565b6040517ff026330a00000000000000000000000000000000000000000000000000000000815267ffffffffffffffff841660048201523360248201529091506001600160a01b0382169063f026330a90604401600060405180830381600087803b15801561025957600080fd5b505af115801561026d573d6000803e3d6000fd5b505050505050565b336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610308576040517f1cf993f40000000000000000000000000000000000000000000000000000000081523360048201526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016602482015260440161015b565b6103128282610578565b5050565b6001546000906001600160a01b0316331461034657604051630543601560e11b815233600482015260240161015b565b6002546040517f2f34077b0000000000000000000000000000000000000000000000000000000081526004810187905267ffffffffffffffff8616602482015263ffffffff8086166044830152841660648201526001600160a01b0390911690632f34077b906084016020604051808303816000875af11580156103ce573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103f291906107ce565b95945050505050565b6001546001600160a01b0316331461042857604051630543601560e11b815233600482015260240161015b565b6002546040517f3015394c000000000000000000000000000000000000000000000000000000008152600481018390526001600160a01b0390911690633015394c90602401600060405180830381600087803b15801561048757600080fd5b505af115801561049b573d6000803e3d6000fd5b5050505050565b6001546000906001600160a01b031633146104d257604051630543601560e11b815233600482015260240161015b565b6002546040517f0f52ffc60000000000000000000000000000000000000000000000000000000081526004810187905263ffffffff8087166024830152851660448201526001600160a01b03848116606483015290911690630f52ffc690349060840160206040518083038185885af1158015610553573d6000803e3d6000fd5b50505050506040513d601f19601f820116820180604052508101906103f291906107ce565b60328160008151811061058d5761058d6107e7565b602002602001015161059f91906107fd565b6105aa90600161081f565b6000555050565b803567ffffffffffffffff811681146105c957600080fd5b919050565b6000602082840312156105e057600080fd5b6105e9826105b1565b9392505050565b634e487b7160e01b600052604160045260246000fd5b6000806040838503121561061957600080fd5b8235915060208084013567ffffffffffffffff8082111561063957600080fd5b818601915086601f83011261064d57600080fd5b81358181111561065f5761065f6105f0565b8060051b604051601f19603f83011681018181108582111715610684576106846105f0565b6040529182528482019250838101850191898311156106a257600080fd5b938501935b828510156106c0578435845293850193928501926106a7565b8096505050505050509250929050565b803563ffffffff811681146105c957600080fd5b600080600080608085870312156106fa57600080fd5b8435935061070a602086016105b1565b9250610718604086016106d0565b9150610726606086016106d0565b905092959194509250565b60006020828403121561074357600080fd5b5035919050565b6001600160a01b038116811461075f57600080fd5b50565b6000806000806080858703121561077857600080fd5b84359350610788602086016106d0565b9250610796604086016106d0565b915060608501356107a68161074a565b939692955090935050565b6000602082840312156107c357600080fd5b81516105e98161074a565b6000602082840312156107e057600080fd5b5051919050565b634e487b7160e01b600052603260045260246000fd5b60008261081a57634e487b7160e01b600052601260045260246000fd5b500690565b8082018082111561084057634e487b7160e01b600052601160045260246000fd5b9291505056fea2646970667358221220d5d2c25e7a3bb47335aa699f2b1425a3b6736e8e3fb7fcc2a7bdbcef3deb765864736f6c63430008100033",
  "deployedBytecode": "0x6080604052600436106100695760003560e01c80632f34077b116100435780632f34077b146100df5780633015394c146100ff578063ff27dd5e1461011f57600080fd5b80630e5ff996146100755780631964176c1461009d5780631fe543e3146100bf57600080fd5b3661007057005b600080fd5b34801561008157600080fd5b5061008b60005481565b60405190815260200160405180910390f35b3480156100a957600080fd5b506100bd6100b83660046105ce565b610132565b005b3480156100cb57600080fd5b506100bd6100da366004610606565b610275565b3480156100eb57600080fd5b5061008b6100fa3660046106e4565b610316565b34801561010b57600080fd5b506100bd61011a366004610731565b6103fb565b61008b61012d366004610762565b6104a2565b6001546001600160a01b0316331461016457604051630543601560e11b81523360048201526024015b60405180910390fd5b600254604080517fa690d7ae00000000000000000000000000000000000000000000000000000000815290516000926001600160a01b03169163a690d7ae916004808301926020929190829003018187875af11580156101c8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101ec91906107b1565b6040517ff026330a00000000000000000000000000000000000000000000000000000000815267ffffffffffffffff841660048201523360248201529091506001600160a01b0382169063f026330a90604401600060405180830381600087803b15801561025957600080fd5b505af115801561026d573d6000803e3d6000fd5b505050505050565b336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610308576040517f1cf993f40000000000000000000000000000000000000000000000000000000081523360048201526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016602482015260440161015b565b6103128282610578565b5050565b6001546000906001600160a01b0316331461034657604051630543601560e11b815233600482015260240161015b565b6002546040517f2f34077b0000000000000000000000000000000000000000000000000000000081526004810187905267ffffffffffffffff8616602482015263ffffffff8086166044830152841660648201526001600160a01b0390911690632f34077b906084016020604051808303816000875af11580156103ce573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103f291906107ce565b95945050505050565b6001546001600160a01b0316331461042857604051630543601560e11b815233600482015260240161015b565b6002546040517f3015394c000000000000000000000000000000000000000000000000000000008152600481018390526001600160a01b0390911690633015394c90602401600060405180830381600087803b15801561048757600080fd5b505af115801561049b573d6000803e3d6000fd5b5050505050565b6001546000906001600160a01b031633146104d257604051630543601560e11b815233600482015260240161015b565b6002546040517f0f52ffc60000000000000000000000000000000000000000000000000000000081526004810187905263ffffffff8087166024830152851660448201526001600160a01b03848116606483015290911690630f52ffc690349060840160206040518083038185885af1158015610553573d6000803e3d6000fd5b50505050506040513d601f19601f820116820180604052508101906103f291906107ce565b60328160008151811061058d5761058d6107e7565b602002602001015161059f91906107fd565b6105aa90600161081f565b6000555050565b803567ffffffffffffffff811681146105c957600080fd5b919050565b6000602082840312156105e057600080fd5b6105e9826105b1565b9392505050565b634e487b7160e01b600052604160045260246000fd5b6000806040838503121561061957600080fd5b8235915060208084013567ffffffffffffffff8082111561063957600080fd5b818601915086601f83011261064d57600080fd5b81358181111561065f5761065f6105f0565b8060051b604051601f19603f83011681018181108582111715610684576106846105f0565b6040529182528482019250838101850191898311156106a257600080fd5b938501935b828510156106c0578435845293850193928501926106a7565b8096505050505050509250929050565b803563ffffffff811681146105c957600080fd5b600080600080608085870312156106fa57600080fd5b8435935061070a602086016105b1565b9250610718604086016106d0565b9150610726606086016106d0565b905092959194509250565b60006020828403121561074357600080fd5b5035919050565b6001600160a01b038116811461075f57600080fd5b50565b6000806000806080858703121561077857600080fd5b84359350610788602086016106d0565b9250610796604086016106d0565b915060608501356107a68161074a565b939692955090935050565b6000602082840312156107c357600080fd5b81516105e98161074a565b6000602082840312156107e057600080fd5b5051919050565b634e487b7160e01b600052603260045260246000fd5b60008261081a57634e487b7160e01b600052601260045260246000fd5b500690565b8082018082111561084057634e487b7160e01b600052601160045260246000fd5b9291505056fea2646970667358221220d5d2c25e7a3bb47335aa699f2b1425a3b6736e8e3fb7fcc2a7bdbcef3deb765864736f6c63430008100033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "rawFulfillRandomWords(uint256,uint256[])": {
        "params": {
          "randomWords": "the VRF output expanded to the requested number of words",
          "requestId": "The Id initially returned by requestRandomWords"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "rawFulfillRandomWords(uint256,uint256[])": {
        "notice": "rawFulfillRandomWords is called by VRFCoordinator when itreceives a valid VRF proof. rawFulfillRandomWords then callsfulfillRandomWords, after validating the origin of the call"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 17027,
        "contract": "src/mocks/VRFConsumerMock.sol:VRFConsumerMock",
        "label": "sRandomWord",
        "offset": 0,
        "slot": "0",
        "type": "t_uint256"
      },
      {
        "astId": 17029,
        "contract": "src/mocks/VRFConsumerMock.sol:VRFConsumerMock",
        "label": "sOwner",
        "offset": 0,
        "slot": "1",
        "type": "t_address"
      },
      {
        "astId": 17032,
        "contract": "src/mocks/VRFConsumerMock.sol:VRFConsumerMock",
        "label": "COORDINATOR",
        "offset": 0,
        "slot": "2",
        "type": "t_contract(IVRFCoordinator)11113"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_contract(IVRFCoordinator)11113": {
        "encoding": "inplace",
        "label": "contract IVRFCoordinator",
        "numberOfBytes": "20"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}